(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{536:function(t,a,v){"use strict";v.r(a);var e=v(6),_=Object(e.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"基本概念"}},[t._v("基本概念")]),t._v(" "),v("h3",{attrs:{id:"阻塞与非阻塞"}},[t._v("阻塞与非阻塞")]),t._v(" "),v("p",[t._v("阻塞与非阻塞，用于描述调用者在等待返回结果时的状态。")]),t._v(" "),v("ul",[v("li",[t._v("阻塞：调用者发起请求后，会一直等待返回结果，这期间当前线程会被挂起（阻塞）。")]),t._v(" "),v("li",[t._v("非阻塞：调用者发起请求后，会立刻返回，当前线程也不会阻塞。该调用不会立刻得到结果，调用者需要定时轮询查看处理状态。")])]),t._v(" "),v("h3",{attrs:{id:"同步与异步"}},[t._v("同步与异步")]),t._v(" "),v("p",[t._v("而同步与异步，用于描述调用结果的返回机制（或者叫通信机制）。")]),t._v(" "),v("ul",[v("li",[t._v("同步：调用者发起请求后，会一直等待返回结果，即由调用者主动等待这个调用结果。")]),t._v(" "),v("li",[t._v("异步：调用者发起请求后，会立刻返回，但不会立刻得到这个结果，而是由被调者在执行结束后主动通知（如 Callback）调用者。")])]),t._v(" "),v("p",[t._v("生活案例说明：说到烧水，我们都是通过热水壶来烧水的。在很久之前，科技还没有这么发达的时候，如果我们要烧水， 需要把水壶放到火炉上，我们通过观察水壶内的水的沸腾程度来判断水有没有烧开。随着科技的发展，现在市面上的水壶都有了提醒功能，当我们把水壶插电之后，水壶水烧开之后会通过声音提醒我们水开了。")]),t._v(" "),v("p",[t._v("对于烧水这件事儿来说，传统水壶的烧水就是同步的，高科技水壶的烧水就是异步的。")]),t._v(" "),v("h3",{attrs:{id:"用户空间、内核空间、系统调用"}},[t._v("用户空间、内核空间、系统调用")]),t._v(" "),v("p",[t._v("操作系统的进程空间可以分为用户空间（User Space）和内核空间（Kernel Space），它们需要不同的执行权限。")]),t._v(" "),v("ul",[v("li",[t._v("大多数系统交互式操作需要在内核空间中运行，比如设备 IO 操作。")]),t._v(" "),v("li",[t._v("我们的应用程序运行在用户空间，是不具备系统级的直接操作权限的。如果应用程序想要访问系统核心功能，必须通过系统调用（System Call）来完成。比如调用"),v("code",[t._v("recv()")]),t._v("函数，会将输入缓冲区中的内容拷贝到用户缓冲区。")]),t._v(" "),v("li",[t._v("系统调用运行在内核空间，是操作系统为应用程序提供的接口。")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://ae02.alicdn.com/kf/He62722084cd944b58aa1ba077eb9992bx.png",alt:"image.png"}})]),t._v(" "),v("h2",{attrs:{id:"五种io模型"}},[t._v("五种IO模型")]),t._v(" "),v("p",[t._v("Linux 系统为我们提供五种可用的 IO 模型：阻塞式 IO 模型、非阻塞式 IO 模型、IO 多路复用模型、信号驱动 IO 模型和异步 IO 模型。其中前四种都是同步IO，而最后一种是异步IO")]),t._v(" "),v("h3",{attrs:{id:"同步阻塞io模型"}},[t._v("同步阻塞IO模型")]),t._v(" "),v("p",[v("code",[t._v("Blocking IO")]),t._v("：应用进程从发起 IO 系统调用，至内核返回成功标识，这整个期间是处于阻塞状态的。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://ae04.alicdn.com/kf/Hea55f51a944e464ca9f93899c2ffdb36l.png",alt:"image.png"}})]),t._v(" "),v("p",[t._v("在Java程序中，使用Socket 套接字来进行网络编程；")]),t._v(" "),v("blockquote",[v("p",[t._v("Socket 中文翻译为套接字，是计算机网络中进程间进行双向通信的端点的抽象。一个 Socket 代表了网络通信的一端，是由操作系统提供的进程间通信机制。")]),t._v(" "),v("p",[t._v("要想实现网络通信，至少需要一对 Socket，其中一个运行在客户端，称之为 Client Socket；另一个运行在服务器端，称之为 Server Socket。")]),t._v(" "),v("p",[t._v("Socket 之间的连接过程可以分为三个步骤：（1）服务器监听；（2）客户端连接；（3）连接确认。")])]),t._v(" "),v("div",{staticClass:"language-java extra-class"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ServerSocket")]),t._v(" server "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ServerSocket")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("6666")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 监听指定端口")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Socket")]),t._v(" sock "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" server"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("accept")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),v("p",[t._v("如果没有客户端连接进来，"),v("code",[t._v("accept()")]),t._v("方法会阻塞并一直等待。如果有多个客户端同时连接进来，"),v("code",[t._v("ServerSocket")]),t._v("会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用"),v("code",[t._v("accept()")]),t._v("就可以获取新的连接。")]),t._v(" "),v("h3",{attrs:{id:"非阻塞io模型"}},[t._v("非阻塞IO模型")]),t._v(" "),v("p",[v("code",[t._v("Non-Blocking")]),t._v("：应用进程可以将 Socket 设置为非阻塞，这样应用进程在发起 IO 系统调用后，会立刻返回。应用进程可以轮询的发起 IO 系统调用，直到内核返回成功标识。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://ae04.alicdn.com/kf/H9426adc43f204825b21e08f193c66689j.png",alt:"image.png"}})]),t._v(" "),v("p",[t._v("在 Java NIO（自Java 1.4以来） 就是一种同步非阻塞模型。")]),t._v(" "),v("p",[t._v("NIO是面向==缓冲区==或者==面向块编程==的。数据读取到一个它稍后处理的缓冲区，需要向缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。")]),t._v(" "),v("p",[t._v("TODO：《Java NIO 的使用》")]),t._v(" "),v("h3",{attrs:{id:"io多路复用模型"}},[t._v("IO多路复用模型")]),t._v(" "),v("p",[v("code",[t._v("IO Multiplexin")]),t._v("：可以将多个应用进程的 Socket 注册到一个 Select（多路复用器）上，然后使用一个进程来监听该 Select（该操作会阻塞），Select 会监听所有注册进来的 Socket。只要有一个 Socket 的数据准备好，就会返回该Socket。再由应用进程发起 IO 系统调用，来完成数据读取。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://ae02.alicdn.com/kf/Hc6faf62b74a24455883418a01914ffd0q.png",alt:"image.png"}})]),t._v(" "),v("p",[t._v("多路复用模型在一些地方也称为是事件驱动IO模型；IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。")]),t._v(" "),v("p",[t._v("通过NIO实现的Reactor模式即是I/O多路复用模型的实现")]),t._v(" "),v("p",[t._v("TODO：《什么是Reactor模式》")]),t._v(" "),v("h3",{attrs:{id:"信号驱动-io-模型"}},[t._v("信号驱动 IO 模型")]),t._v(" "),v("p",[v("code",[t._v("Signal Driven IO")]),t._v("：可以为 Socket 开启信号驱动 IO 功能，应用进程需向内核注册一个信号处理程序，该操作并立即返回。当内核中有数据准备好，会发送一个信号给应用进程，应用进程便可以在信号处理程序中发起 IO 系统调用，来完成数据读取了。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://ae02.alicdn.com/kf/Hbd93a8340c814955a47eb78aef21d51fH.png",alt:"image.png"}})]),t._v(" "),v("p",[t._v("系统注册了ISGIO信号处理函数，并且启动了信号驱动式IO后，就可以继续执行程序了，等到数据报准备好之后，内核会发送一个SIGIO信号给应用进程，然后应用进程在信号处理函数中调用recvfrom读取数据报。")]),t._v(" "),v("p",[t._v("这种模型在内核等待数据报达到期间进程不会被阻塞，可以继续执行")]),t._v(" "),v("h3",{attrs:{id:"异步io模型"}},[t._v("异步IO模型")]),t._v(" "),v("p",[v("code",[t._v("Asynchronous IO")]),t._v("：应用进程发起 IO 系统调用后，会立即返回。当内核中数据完全准备后，并且也复制到了用户空间，会产生一个信号来通知应用进程。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://ae05.alicdn.com/kf/H342c4a9cb4924cd0971c1dff3c219613J.png",alt:"image.png"}})]),t._v(" "),v("p",[t._v("步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。注意，异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。")]),t._v(" "),v("p",[t._v("通过AIO实现的Proactor模式即是异步I/O模型的实现")])])}),[],!1,null,null,null);a.default=_.exports}}]);